#summary One-sentence summary of this page.

<wiki:toc max_depth="3" />

= Home page =

For the moment we'll ignore the CDs and begin writing the home page

Create a new folder mycds in your Karrigell distribution, under the www folder. With your favorite text editor, save this text in a file called index.py
{{{
def index():
    return "<h1>My CD collection</h1>"
}}}
In your browser ask localhost/mycds/index.py/index

Karrigell maps urls to functions in Python scripts : here, index.py/index means that the function index() will send the data back to the browser

In fact

  * if you don't specify a function name, the index() function in the script will be run, so you could have asked localhost/mycds/index.py
  * and if you don't even specify a script name in a folder, the script called index will be run. So all you have to type really is localhost/mycds

Notice the <tt>return</tt> statement in the index() function. Karrigell sends the result of the function to the browser (more precisely, the string representation of the result) ; by default, this content is supposed to be HTML code

= HTMLTags =

Functions can return raw HTML strings, but Karrigell has a more elegant way of generating HTML. Rewrite the content of index.py with :

{{{
def index():
    return H1("My CD collection")
}}}

The name <tt>H1</tt> matches the HTML tags H1 ; all valid HTML tags (including HTML5) have their name available in Python scripts (in uppercase letters)

<tt>H1</tt> is a class, in the example it is instanciated with "My CD collection" as the first argument. The string representation of this instance is the matching HTML code

Although you can write applications without using these names, it will make your code much cleaner and easier to review than with raw HTML strings

= Adding a page counter =

The page counter will print the number of times that the page has been seen. We'll use a file, counter.txt, to store the number of visits and increment it for each visit

{{{
def index():
    body = H1("My CD collection")
    try:
        visits = int(open('counter.txt').read())
    except IOError:
        # first visit : the file does not exist
        visits = 0
    visits += 1
    out = open('counter.txt','w')
    out.write(str(visits))
    out.close()
    body += "%s visits" %visits
    return body
}}}
Each time the page is reloaded, you will see the number of visits incremented by 1

Notice that the file is opened by the usual open() function. The current directory is the one where the server script stands ; so you will see that the file counter.txt is located in the directory <tt>www</tt>, _not_ in the subdirectory <tt>mycds</tt>

= A better page counter =

A page counter should not increment if the same user repeatedly reloads the same page. This requires a way to identify the browser which is sending the request. For this task, web programming provides session management, and Karrigell has a very simple implementation of this concept

Use the built-in Session() function

Karrigell scripts are run in a namespace prepared by the framework : among the names available in scripts, you have this Session() function, which returns an object specific to each individual client (it uses cookies). This object is an ordinary Python object, to which you can set any attribute you like

Here, for a new client, we will create an attribute user to the session object. If a client requests the home page and his session object already has this attribute, the counter will not be incremented
{{{
def index():
    body = H1("My CD collection")
    try:
        visits = int(open('counter.txt').read())
    except IOError:
        # first visit : the file does not exist
        visits = 0
    if not "user" in Session():
        visits += 1
        out = open('counter.txt','w')
        out.write(str(visits))
        out.close()
        Session()["user"] = None   # create attribute user
    body += "%s visits" %visits
    return body
}}}
= Importing scripts =

This page counter could be used in other parts of the application, so it's better to put it in a separate file : save this part of the script in counter.py
{{{
def nb_visits():
    try:
        visits = int(open('counter.txt').read())
    except IOError:
        # first visit : the file does not exist
        visits = 0
    if not hasattr(Session(),"user"):
        visits += 1
        out = open('counter.txt','w')
        out.write(str(visits))
        out.close()
        Session().user = None   # create attribute user
    return visits
}}}
To use this script in the home page, change the script index.py to this :
{{{
counter = Import('counter.py')

def index():
    body = H1("My CD collection")
    body += counter.nb_visits()+" visits"
    return body
}}}
Import() is another Karrigell built-in function : it takes a script url as argument, and returns an object that behaves exactly like an imported module

So, you may wonder, why not use the usual Python keyword <tt>import</tt> ? This is because of the mechanism used by the Python interpreter to find a module by its name : it searches a module of this name in a list of directories, and in a multi threaded environment such as a web server, there is no reliable way of being sure that the directory of a Karrigell script is inside this list

= Logging in/out =

Let's add a link for users to log in to the application
{{{
counter = Import('counter.py')

def index():
    body = H1("My CD collection")
    body += A("Login",href="login")
    body += counter.nb_visits()+" visits"
    return body
}}}
To create the HTML anchor, we use the built-in class A, with the text as first argument, and the attribute 'href' set to "login". The string representation of this instance will be
{{{
<a href="login">Login</a>
}}}

The href attribute, "login", is a relative url to the base url, `host/mycds/index.py/index`, so it resolves to `host/mycds/index.py/login`, meaning that the link will invoke the execution of the function login() in the script index.py

This function will generate an HTML form asking the user's login and password, and submitting these values to an authentication test
{{{
def login():
    body = H1('Login')
    form = FORM(action="check_login",method="post")
    form <= 'Login '+INPUT(name="login")+BR()
    form <= 'Password '+ INPUT(Type="password",name="passwd")
    form <= INPUT(Type="submit",value="Ok")
    body += form
    return body
}}}
Note how the form is built : first the instance of FORM is created, with the attributes `action` and `method`. Then, the form fields are added using the operator `<=`. Of course it has nothing to see with "lesser or equal" : think of it as a left arrow, meaning "add child" to the tree node

Also note that
  * you can freely add tag objects and strings
  * for attributes that have the same name as a Python keyword, such as `type` or `class`, you must capitalize the attribute name to avoid syntax errors

The attribute "action" for the form is `check_login`. Again, this means that the function check_login() in index.ky will be run

Unlike index() and login(), this function will take arguments : the submitted login and password. The arguments must be called like the names used in the input fields of the form : `login` and `passwd`. For the moment we'll use a very simple test to see if the user is allowed to log in
{{{
def check_login(login,passwd):
    if login=="john" and passwd=="doe":
        Session()["user"] = login
        return "logged in"
    else:
        return "try again"
}}}
Inside this function, if the test succeeds, the attribute user of the session object is set to the user's login

For the moment, all we have is the result of the test. After the test, we should be automatically sent back to the home page. The HTTP protocol provides a redirection feature, and Karrigell implementation is once again very straightforward : a built-in exception called HTTP_REDIRECTION

Change the function check_login() like this :
{{{
def check_login(login,passwd):
    if login=="john" and passwd=="doe":
        Session().user = login
    raise HTTP_REDIRECTION,"index"
}}}
This means that after the function is run, the browser redirects to the specified url, here the one that matches the function index() in the script

We can now change the home page to welcome the authenticated user with his name, and allow him to logout :
{{{
def index():
    print "<h1>My CD collection</h1>"
    logged = hasattr(Session(),"user") and Session().user is not None
    if logged:
        print 'Logged in as %s<br>' %Session().user
        print '<a href="logout">Logout</a><br>'
    else:
        print '<a href="login">Login</a><br>'
    Include('../counter.py',counter_file='counter.txt')
}}}
The logout function will only set Session().user to None and redirect to the home page :
{{{
def logout():
    del Session().user
    raise HTTP_REDIRECTION,"index"
}}}
= Summary =

The programming style used by Karrigell is based on namespace : in the scripts, instead of importing modules or using environment variables, a number of built-in names are available for the most common tasks. So far we have covered session management with the built-in name Session(), inclusion of scripts with Include() and HTTP redirection with the built-in exception HTTP_REDIRECTION

This makes programming with Karrigell extremely straightforward, thus easy to code and to maintain

While other formats are available (see the documentation for pure-Python scripts, CGI, Python Inside HTML, HTML Inside Python) I suggest to use "Karrigell Services" to group most of the application logic in one script ; peripheric modules can be imported or included

In the next section we will write the code to manage the CD database